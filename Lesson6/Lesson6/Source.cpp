#define _CRT_SECURE_NO_WARNINGS
#include <conio.h>
#include <math.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <thread>
#include "ObjectsGamePlay.h"
#include "ConsoleHelper.h" 
#include "Score.h"
#include "GamePlay.h"



//1. Зафиксировать размеры карты и нарисовать на границах стену из #.
//2. Не позволять звездочке выходить за границу.
//2.5 При вверх  - есть бага
//3. Заполнить массив стен рандомными стенами в количестве n штук.
//4. Нарисовать стены из массива.
//5. Не позволять звездочке наступать на стены.
//6/ Сделать правильное движение змейки. Сейчас двигается только голова, тело стоит на месте.
// Змейка движется так: голова встает на новую позицию, а все следующие элементы двигаются вперед
// {2,0} {3,0} {3,1} {3,2} {4,2}
// {1,0} {2,0} {3,0} {3,1} {3,2}
// 7 добавить на поле в случаеное место еду (1 клетка), кога голова ее касается, то написать Hello
// Еда генерируется в новом месте
// задания
// 1. Убрать _wals, _foods. Сделать только массив fields
// 2. Убарть логику score в отдельный класс
// 3. Перевести змейку на вектор. Сделать чтоб голова была в начале массива


// 1. Разнести логику по файликам

// 2. В классе Score не рисовать стену, ит не принимать размеры поля. А принимать только точку куда писать.
// 3. Заюзать енам Snake в поле
// 4. Сделать кольцеовй массив
// 5. Добавить врагов 
// 6. Добавить к змейке и врагам скорость
// 7. Сделать так чтоб, если враг касается змейки, то он ее "режет"
// 8. Сделать врагам более умную логику движения. Использовать алгоритм поиска наикратчайшего пути от врага до змеи.

char RandomMove()
{
	char ch;
	switch (std::rand() % 4)
	{
	case 0: ch = 'w'; break;
	case 1: ch = 'a'; break;
	case 2: ch = 's'; break;
	case 3: ch = 'd'; break;
	default:
		break;
	}
	return ch;
}

#include "Parallel.h"

int main()
{
	//GamePlay<10,20> game;
	GamePlay game;
	ConsoleHelper cs;

	std::thread keyboard_thread(&GamePlay::GetKey, &game);
	//std::thread sound_thread(&GamePlay::PlaySoundWithBeep, &game);

	while (true)
	{
		game.MoveAsterisk();
	}
	keyboard_thread.join();
	//sound_thread.join();
	std::system("pause");
}